#
# LibNeubot interface - Public domain.
# WARNING: Autogenerated file - do not edit!
#

# pylint: disable = C0111

import ctypes
import logging
import sys

if sys.platform == "darwin":
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.dylib.1"
else:
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.so.1"

LIBNEUBOT = ctypes.CDLL(LIBNEUBOT_NAME)
LIBNEUBOT_OBJECTS = set()

NEUBOT_SLOT_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)
NEUBOT_SLOT_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,
  ctypes.c_char_p)

NEUBOT_HOOK_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)
NEUBOT_HOOK_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,
  ctypes.c_char_p)

class NeubotHookClosure(object):
    pass

#
# NeubotEchoServer prototypes:
#

LIBNEUBOT.NeubotEchoServer_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotEchoServer_construct.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int,
    ctypes.c_char_p,
    ctypes.c_char_p,
)

#
# NeubotHttpClient prototypes:
#

LIBNEUBOT.NeubotHttpClient_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotHttpClient_construct.argtypes = (
    ctypes.c_void_p,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    ctypes.py_object,
)

LIBNEUBOT.NeubotHttpClient_connect.restype = ctypes.c_int
LIBNEUBOT.NeubotHttpClient_connect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_char_p,
    ctypes.c_char_p,
    ctypes.c_char_p,
)

LIBNEUBOT.NeubotHttpClient_write.restype = ctypes.c_int
LIBNEUBOT.NeubotHttpClient_write.argtypes = (
    ctypes.c_void_p,
    ctypes.c_char_p,
    ctypes.c_size_t,
)

LIBNEUBOT.NeubotHttpClient_writes.restype = ctypes.c_int
LIBNEUBOT.NeubotHttpClient_writes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_char_p,
)

LIBNEUBOT.NeubotHttpClient_flush.restype = ctypes.c_int
LIBNEUBOT.NeubotHttpClient_flush.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotHttpClient_code.restype = ctypes.c_int
LIBNEUBOT.NeubotHttpClient_code.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotHttpClient_reason.restype = ctypes.c_char_p
LIBNEUBOT.NeubotHttpClient_reason.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotHttpClient_header.restype = ctypes.c_char_p
LIBNEUBOT.NeubotHttpClient_header.argtypes = (
    ctypes.c_void_p,
    ctypes.c_char_p,
)

LIBNEUBOT.NeubotHttpClient_body_length.restype = ctypes.c_size_t
LIBNEUBOT.NeubotHttpClient_body_length.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotHttpClient_body_string.restype = ctypes.c_char_p
LIBNEUBOT.NeubotHttpClient_body_string.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotHttpClient_close.argtypes = (
    ctypes.c_void_p,
)

#
# NeubotPollable prototypes:
#

LIBNEUBOT.NeubotPollable_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotPollable_construct.argtypes = (
    ctypes.c_void_p,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPollable_attach.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_attach.argtypes = (
    ctypes.c_void_p,
    ctypes.c_longlong,
)

LIBNEUBOT.NeubotPollable_detach.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_fileno.restype = ctypes.c_longlong
LIBNEUBOT.NeubotPollable_fileno.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_readable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_set_readable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_unset_readable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_unset_readable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_writable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_set_writable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_unset_writable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_unset_writable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_timeout.argtypes = (
    ctypes.c_void_p,
    ctypes.c_double,
)

LIBNEUBOT.NeubotPollable_clear_timeout.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_close.argtypes = (
    ctypes.c_void_p,
)

#
# NeubotPoller prototypes:
#

LIBNEUBOT.NeubotPoller_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotPoller_construct.argtypes = (
)

LIBNEUBOT.NeubotPoller_sched.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_sched.argtypes = (
    ctypes.c_void_p,
    ctypes.c_double,
    NEUBOT_HOOK_VO,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPoller_defer_read.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_defer_read.argtypes = (
    ctypes.c_void_p,
    ctypes.c_longlong,
    NEUBOT_HOOK_VO,
    NEUBOT_HOOK_VO,
    ctypes.py_object,
    ctypes.c_double,
)

LIBNEUBOT.NeubotPoller_defer_write.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_defer_write.argtypes = (
    ctypes.c_void_p,
    ctypes.c_longlong,
    NEUBOT_HOOK_VO,
    NEUBOT_HOOK_VO,
    ctypes.py_object,
    ctypes.c_double,
)

LIBNEUBOT.NeubotPoller_resolve.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_resolve.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int,
    ctypes.c_char_p,
    NEUBOT_HOOK_VOS,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPoller_loop.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPoller_break_loop.argtypes = (
    ctypes.c_void_p,
)

#
# NeubotEchoServer wrapper:
#

class EchoServer(object):

    def __init__(self, poller, use_ipv6, address, port):
        # We cannot destroy until the object is complete
        self._can_destroy = False
        self._context = LIBNEUBOT.NeubotEchoServer_construct(poller._context,
          use_ipv6, address, port)
        if not self._context:
            raise RuntimeError('out of memory')
        # From now on we can destroy this object
        self._can_destroy = True
        LIBNEUBOT_OBJECTS.add(self)

#
# NeubotHttpClient wrapper:
#

class HttpClient(object):

    #
    # <Slots>
    #

    def handle_begin(self):
        pass

    @staticmethod
    def _handle_begin_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_begin()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_body(self):
        pass

    @staticmethod
    def _handle_body_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_body()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_close(self):
        pass

    @staticmethod
    def _handle_close_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_close()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_connect(self):
        pass

    @staticmethod
    def _handle_connect_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_connect()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_end(self):
        pass

    @staticmethod
    def _handle_end_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_end()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_flush(self):
        pass

    @staticmethod
    def _handle_flush_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_flush()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_headers(self):
        pass

    @staticmethod
    def _handle_headers_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_headers()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    #
    # </Slots>
    #

    def __init__(self, poller):
        self._c_handle_begin_ = NEUBOT_SLOT_VO(self._handle_begin_)
        self._c_handle_body_ = NEUBOT_SLOT_VO(self._handle_body_)
        self._c_handle_close_ = NEUBOT_SLOT_VO(self._handle_close_)
        self._c_handle_connect_ = NEUBOT_SLOT_VO(self._handle_connect_)
        self._c_handle_end_ = NEUBOT_SLOT_VO(self._handle_end_)
        self._c_handle_flush_ = NEUBOT_SLOT_VO(self._handle_flush_)
        self._c_handle_headers_ = NEUBOT_SLOT_VO(self._handle_headers_)
        self._c_self = ctypes.py_object(self)
        # We cannot destroy until the object is complete
        self._can_destroy = False
        self._context = LIBNEUBOT.NeubotHttpClient_construct(poller._context,
          self._c_handle_begin_, self._c_handle_body_, self._c_handle_close_,
          self._c_handle_connect_, self._c_handle_end_, self._c_handle_flush_,
          self._c_handle_headers_, self._c_self)
        if not self._context:
            raise RuntimeError('out of memory')
        # From now on we can destroy this object
        self._can_destroy = True
        LIBNEUBOT_OBJECTS.add(self)

    def connect(self, family, address, port):
        retval = LIBNEUBOT.NeubotHttpClient_connect(self._context, family,
          address, port)
        if retval != 0:
            raise RuntimeError('connect failed')
        return retval

    def write(self, data, count):
        retval = LIBNEUBOT.NeubotHttpClient_write(self._context, data, count)
        if retval != 0:
            raise RuntimeError('write failed')
        return retval

    def writes(self, str):
        retval = LIBNEUBOT.NeubotHttpClient_writes(self._context, str)
        if retval != 0:
            raise RuntimeError('writes failed')
        return retval

    def flush(self):
        retval = LIBNEUBOT.NeubotHttpClient_flush(self._context)
        if retval != 0:
            raise RuntimeError('flush failed')
        return retval

    def code(self):
        return LIBNEUBOT.NeubotHttpClient_code(self._context)

    def reason(self):
        return LIBNEUBOT.NeubotHttpClient_reason(self._context)

    def header(self, key):
        return LIBNEUBOT.NeubotHttpClient_header(self._context, key)

    def body_length(self):
        return LIBNEUBOT.NeubotHttpClient_body_length(self._context)

    def body_string(self):
        return LIBNEUBOT.NeubotHttpClient_body_string(self._context)

    def close(self):
        if not self._can_destroy:
            return
        # Idempotent destructor for safety
        self._can_destroy = False
        LIBNEUBOT_OBJECTS.remove(self)
        LIBNEUBOT.NeubotHttpClient_close(self._context)

#
# NeubotPollable wrapper:
#

class Pollable(object):

    #
    # <Slots>
    #

    def handle_read(self):
        pass

    @staticmethod
    def _handle_read_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_read()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_write(self):
        pass

    @staticmethod
    def _handle_write_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_write()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    def handle_close(self):
        pass

    @staticmethod
    def _handle_close_(opaque):
        # pylint: disable = W0702
        try:
            opaque.handle_close()
        except:
            logging.warning('Exception', exc_info=1)
            opaque.close()
        # pylint: enable = W0702

    #
    # </Slots>
    #

    def __init__(self, poller):
        self._c_handle_read_ = NEUBOT_SLOT_VO(self._handle_read_)
        self._c_handle_write_ = NEUBOT_SLOT_VO(self._handle_write_)
        self._c_handle_close_ = NEUBOT_SLOT_VO(self._handle_close_)
        self._c_self = ctypes.py_object(self)
        # We cannot destroy until the object is complete
        self._can_destroy = False
        self._context = LIBNEUBOT.NeubotPollable_construct(poller._context,
          self._c_handle_read_, self._c_handle_write_, self._c_handle_close_,
          self._c_self)
        if not self._context:
            raise RuntimeError('out of memory')
        # From now on we can destroy this object
        self._can_destroy = True
        LIBNEUBOT_OBJECTS.add(self)

    def attach(self, filenum):
        retval = LIBNEUBOT.NeubotPollable_attach(self._context, filenum)
        if retval != 0:
            raise RuntimeError('attach failed')
        return retval

    def detach(self):
        LIBNEUBOT.NeubotPollable_detach(self._context)

    def fileno(self):
        return LIBNEUBOT.NeubotPollable_fileno(self._context)

    def set_readable(self):
        retval = LIBNEUBOT.NeubotPollable_set_readable(self._context)
        if retval != 0:
            raise RuntimeError('set_readable failed')
        return retval

    def unset_readable(self):
        retval = LIBNEUBOT.NeubotPollable_unset_readable(self._context)
        if retval != 0:
            raise RuntimeError('unset_readable failed')
        return retval

    def set_writable(self):
        retval = LIBNEUBOT.NeubotPollable_set_writable(self._context)
        if retval != 0:
            raise RuntimeError('set_writable failed')
        return retval

    def unset_writable(self):
        retval = LIBNEUBOT.NeubotPollable_unset_writable(self._context)
        if retval != 0:
            raise RuntimeError('unset_writable failed')
        return retval

    def set_timeout(self, delta):
        LIBNEUBOT.NeubotPollable_set_timeout(self._context, delta)

    def clear_timeout(self):
        LIBNEUBOT.NeubotPollable_clear_timeout(self._context)

    def close(self):
        if not self._can_destroy:
            return
        # Idempotent destructor for safety
        self._can_destroy = False
        LIBNEUBOT_OBJECTS.remove(self)
        LIBNEUBOT.NeubotPollable_close(self._context)

#
# NeubotPoller wrapper:
#

class Poller(object):

    #
    # <Hooks>
    #

    @staticmethod
    def _sched_callback_(closure):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_callback(closure.opaque)

    @staticmethod
    def _defer_read_handle_ok_(closure):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_handle_ok(closure.opaque)

    @staticmethod
    def _defer_read_handle_timeout_(closure):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_handle_timeout(closure.opaque)

    @staticmethod
    def _defer_write_handle_ok_(closure):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_handle_ok(closure.opaque)

    @staticmethod
    def _defer_write_handle_timeout_(closure):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_handle_timeout(closure.opaque)

    @staticmethod
    def _resolve_callback_(closure, string):
        LIBNEUBOT_OBJECTS.remove(closure)
        closure.pyfunc_callback(closure.opaque, string)

    #
    # </Hooks>
    #

    def __init__(self):
        # We cannot destroy until the object is complete
        self._can_destroy = False
        self._context = LIBNEUBOT.NeubotPoller_construct()
        if not self._context:
            raise RuntimeError('out of memory')
        # From now on we can destroy this object
        self._can_destroy = True
        LIBNEUBOT_OBJECTS.add(self)

        # Initialise hooks
        self._sched_callback = NEUBOT_HOOK_VO(
          self._sched_callback_)
        self._defer_read_handle_ok = NEUBOT_HOOK_VO(
          self._defer_read_handle_ok_)
        self._defer_read_handle_timeout = NEUBOT_HOOK_VO(
          self._defer_read_handle_timeout_)
        self._defer_write_handle_ok = NEUBOT_HOOK_VO(
          self._defer_write_handle_ok_)
        self._defer_write_handle_timeout = NEUBOT_HOOK_VO(
          self._defer_write_handle_timeout_)
        self._resolve_callback = NEUBOT_HOOK_VOS(
          self._resolve_callback_)

    def sched(self, delta, callback, opaque):
        closure = NeubotHookClosure()
        # pylint: disable = W0201
        closure.pyfunc_callback = callback
        closure.opaque = opaque
        # pylint: enable = W0201
        LIBNEUBOT_OBJECTS.add(closure)
        retval = LIBNEUBOT.NeubotPoller_sched(self._context, delta,
          self._sched_callback, closure)
        if retval != 0:
            raise RuntimeError('sched failed')
        return retval

    def defer_read(self, fileno, handle_ok, handle_timeout, opaque, timeout):
        closure = NeubotHookClosure()
        # pylint: disable = W0201
        closure.pyfunc_handle_ok = handle_ok
        closure.pyfunc_handle_timeout = handle_timeout
        closure.opaque = opaque
        # pylint: enable = W0201
        LIBNEUBOT_OBJECTS.add(closure)
        retval = LIBNEUBOT.NeubotPoller_defer_read(self._context, fileno,
          self._defer_read_handle_ok, self._defer_read_handle_timeout, closure,
          timeout)
        if retval != 0:
            raise RuntimeError('defer_read failed')
        return retval

    def defer_write(self, fileno, handle_ok, handle_timeout, opaque,
          timeout):
        closure = NeubotHookClosure()
        # pylint: disable = W0201
        closure.pyfunc_handle_ok = handle_ok
        closure.pyfunc_handle_timeout = handle_timeout
        closure.opaque = opaque
        # pylint: enable = W0201
        LIBNEUBOT_OBJECTS.add(closure)
        retval = LIBNEUBOT.NeubotPoller_defer_write(self._context, fileno,
          self._defer_write_handle_ok, self._defer_write_handle_timeout,
          closure, timeout)
        if retval != 0:
            raise RuntimeError('defer_write failed')
        return retval

    def resolve(self, use_ipv6, name, callback, opaque):
        closure = NeubotHookClosure()
        # pylint: disable = W0201
        closure.pyfunc_callback = callback
        closure.opaque = opaque
        # pylint: enable = W0201
        LIBNEUBOT_OBJECTS.add(closure)
        retval = LIBNEUBOT.NeubotPoller_resolve(self._context, use_ipv6, name,
          self._resolve_callback, closure)
        if retval != 0:
            raise RuntimeError('resolve failed')
        return retval

    def loop(self):
        LIBNEUBOT.NeubotPoller_loop(self._context)

    def break_loop(self):
        LIBNEUBOT.NeubotPoller_break_loop(self._context)

