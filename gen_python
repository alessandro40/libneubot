#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

def pylang_type(types, name):
    return types.get(name, name)

def gen_pylang_init(stream, types, class_name, init_args, slots):
    stream.write("    ")
    stream.write("def __init__(self")
    for arg in init_args:
        stream.write(", %s" % arg[1])
    stream.write("):\n")
    stream.write("        ")
    stream.write("self._context = ")
    stream.write("LIBNEUBOT.%s_construct(" % class_name)
    for index, arg in enumerate(init_args):
        argtype, argname = arg
        argtype = pylang_type(types, argtype)
        stream.write("%s(%s)" % (argtype, argname))
        if index < len(init_args) - 1:
            stream.write(", ")
    stream.write(")\n")
    stream.write("        ")
    stream.write("if not self._context:\n")
    stream.write("            ")
    stream.write("raise RuntimeError('out of memory')\n")
    if slots:
        stream.write("        ")
        stream.write("self._pyself = ctypes.py_object(self)\n")
        stream.write("        ")
        stream.write("self._cb_type = ctypes.CFUNCTYPE(None, ")
        stream.write("ctypes.py_object)\n")
    for slot in slots:
        stream.write("        ")
        stream.write("self._%s_cb = self._cb_type(self._%s)\n" % (
          slot, slot))
        stream.write("        ")
        stream.write("LIBNEUBOT.%s_set_%s_slot(self._context, " % (class_name,
                     slot))
        stream.write("self._%s_cb, self._pyself)\n" % slot)
    stream.write("        ")
    stream.write("LIBNEUBOT_OBJECTS.add(self)\n")
    stream.write("\n")

def gen_pylang_slot(stream, class_name, slot_name):
    stream.write("    ")
    stream.write("def %s(self):\n" % slot_name)
    stream.write("        ")
    stream.write("pass\n")
    stream.write("\n")
    stream.write("    ")
    stream.write("@staticmethod\n")
    stream.write("    ")
    stream.write("def _%s(opaque):\n" % slot_name)
    stream.write("        ")
    stream.write("self = ctypes.cast(opaque, ctypes.py_object)\n")
    stream.write("        ")
    stream.write("self.%s()\n" % slot_name)
    stream.write("\n")

def gen_pylang_del(stream, class_name):
    stream.write("    ")
    stream.write("def free(self):\n")
    stream.write("        ")
    stream.write("LIBNEUBOT.%s_free(self._context)\n" % class_name)
    stream.write("        ")
    stream.write("LIBNEUBOT_OBJECTS.remove(self)\n")
    stream.write("\n")

def gen_pylang_method(stream, types, class_name, retval_type,
                      meth_name, meth_args):
    stream.write("    ")
    stream.write("def %s(self" % meth_name)
    if meth_args:
        for meth_arg in meth_args:
            stream.write(", %s" % meth_arg[1])
    stream.write("):\n")
    stream.write("        ")
    if retval_type != "void":
        stream.write("result = ")
    stream.write("LIBNEUBOT.%s_%s(self._context" % (class_name, meth_name))
    if meth_args:
        for meth_arg in meth_args:
            stream.write(", %s" % meth_arg[1])
    stream.write(")\n")
    if retval_type != "void":
        if retval_type == "status_t":
            stream.write("        ")
            stream.write("if result != 0:\n")
            stream.write("            ")
            stream.write("raise RuntimeError('%s failed')\n" % meth_name)
        stream.write("        ")
        stream.write("return result\n")
    stream.write("\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)
    stream = sys.stdout

    stream.write("#\n")
    stream.write("# LibNeubot interface - Public domain.\n")
    stream.write("# WARNING: Autogenerated file - do not edit!\n")
    stream.write("#\n")
    stream.write("\n")

    types = {
        "Object": "ctypes.py_object",
        "cstring": "ctypes.c_char_p",
        "status_t": "ctypes.c_int",
        "void_p": "ctypes.c_void_p",
    }

    # Process all class names once, to register all the cast functions
    for class_name in sorted(interface["classes"]):
        stream.write("def %s_p(sth):\n" % class_name)
        stream.write("    ")
        stream.write("if sth.__class__.__name__ != '%s':\n" % class_name)
        stream.write("        ")
        stream.write("raise RuntimeError('type is not %s')\n" % class_name)
        stream.write("    ")
        stream.write("return sth._context\n")
        stream.write("\n")

    for class_name in sorted(interface["classes"]):
        stream.write("class %s(object):\n" % class_name)
        stream.write("\n")

        ctor = None
        slots = []

        for method_info in interface["classes"][class_name]:
            if method_info[0] == "__construct__":
                ctor = method_info[1:]
            elif method_info[0] == "__slot__":
                gen_pylang_slot(stream, class_name, method_info[1])
                slots.append(method_info[1])
            elif method_info[0] == "__destroy__":
                gen_pylang_del(stream, class_name)
            else:
                gen_pylang_method(stream, types, class_name, method_info[0],
                  method_info[1], method_info[2:])

        if ctor != None:
            gen_pylang_init(stream, types, class_name, ctor, slots)

if __name__ == "__main__":
    main()
