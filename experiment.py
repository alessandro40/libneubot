#
# LibNeubot interface - Public domain.
# WARNING: Autogenerated file - do not edit!
#

def NeubotPollable_p(sth):
    if sth.__class__.__name__ != 'NeubotPollable':
        raise RuntimeError('type is not NeubotPollable')
    return sth._context

def NeubotPoller_p(sth):
    if sth.__class__.__name__ != 'NeubotPoller':
        raise RuntimeError('type is not NeubotPoller')
    return sth._context

class NeubotPollable(object):

    def handle_read(self):
        pass

    @staticmethod
    def _handle_read(opaque):
        self = ctypes.cast(opaque, ctypes.py_object)
        self.handle_read()

    def handle_write(self):
        pass

    @staticmethod
    def _handle_write(opaque):
        self = ctypes.cast(opaque, ctypes.py_object)
        self.handle_write()

    def handle_free(self):
        pass

    @staticmethod
    def _handle_free(opaque):
        self = ctypes.cast(opaque, ctypes.py_object)
        self.handle_free()

    def free(self):
        LIBNEUBOT.NeubotPollable_free(self._context)
        LIBNEUBOT_OBJECTS.remove(self)

    def poller(self):
        result = LIBNEUBOT.NeubotPollable_poller(self._context)
        return result

    def attach(self, filenum):
        result = LIBNEUBOT.NeubotPollable_attach(self._context, filenum)
        if result != 0:
            raise RuntimeError('attach failed')
        return result

    def detach(self):
        LIBNEUBOT.NeubotPollable_detach(self._context)

    def fileno(self):
        result = LIBNEUBOT.NeubotPollable_fileno(self._context)
        return result

    def set_readable(self):
        result = LIBNEUBOT.NeubotPollable_set_readable(self._context)
        if result != 0:
            raise RuntimeError('set_readable failed')
        return result

    def unset_readable(self):
        result = LIBNEUBOT.NeubotPollable_unset_readable(self._context)
        if result != 0:
            raise RuntimeError('unset_readable failed')
        return result

    def set_writable(self):
        result = LIBNEUBOT.NeubotPollable_set_writable(self._context)
        if result != 0:
            raise RuntimeError('set_writable failed')
        return result

    def unset_writable(self):
        result = LIBNEUBOT.NeubotPollable_unset_writable(self._context)
        if result != 0:
            raise RuntimeError('unset_writable failed')
        return result

    def set_timeout(self, delta):
        LIBNEUBOT.NeubotPollable_set_timeout(self._context, delta)

    def clear_timeout(self):
        LIBNEUBOT.NeubotPollable_clear_timeout(self._context)

    def __init__(self, poller):
        self._context = LIBNEUBOT.NeubotPollable_construct(NeubotPoller_p(poller))
        if not self._context:
            raise RuntimeError('out of memory')
        self._pyself = ctypes.py_object(self)
        self._cb_type = ctypes.CFUNCTYPE(None, ctypes.py_object)
        self._handle_read_cb = self._cb_type(self._handle_read)
        LIBNEUBOT.NeubotPollable_set_handle_read_slot(self._context, self._handle_read_cb, self._pyself)
        self._handle_write_cb = self._cb_type(self._handle_write)
        LIBNEUBOT.NeubotPollable_set_handle_write_slot(self._context, self._handle_write_cb, self._pyself)
        self._handle_free_cb = self._cb_type(self._handle_free)
        LIBNEUBOT.NeubotPollable_set_handle_free_slot(self._context, self._handle_free_cb, self._pyself)
        LIBNEUBOT_OBJECTS.add(self)

class NeubotPoller(object):

    def free(self):
        LIBNEUBOT.NeubotPoller_free(self._context)
        LIBNEUBOT_OBJECTS.remove(self)

    def break_loop(self):
        LIBNEUBOT.NeubotPoller_break_loop(self._context)

    def __init__(self):
        self._context = LIBNEUBOT.NeubotPoller_construct()
        if not self._context:
            raise RuntimeError('out of memory')
        LIBNEUBOT_OBJECTS.add(self)

