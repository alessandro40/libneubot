#
# LibNeubot interface - Public domain.
# WARNING: Autogenerated file - do not edit!
#

# pylint: disable = C0111

import ctypes
import sys

if sys.platform == "darwin":
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.dylib.1"
else:
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.so.1"

LIBNEUBOT = ctypes.CDLL(LIBNEUBOT_NAME)
LIBNEUBOT_OBJECTS = set()

NEUBOT_SLOT_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)
NEUBOT_SLOT_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,
  ctypes.c_char_p)

NEUBOT_HOOK_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)
NEUBOT_HOOK_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,
  ctypes.c_char_p)

class NeubotHookVoContext(object):
    def __init__(self, callback, opaque, cfunc):
        self.callback = callback
        self.opaque = opaque
        self.cfunc = NEUBOT_HOOK_VO(cfunc)

LIBNEUBOT.NeubotEchoServer_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotEchoServer_construct.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int,
    ctypes.c_char_p,
    ctypes.c_char_p,
)

LIBNEUBOT.NeubotPollable_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotPollable_construct.argtypes = (
    ctypes.c_void_p,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    NEUBOT_SLOT_VO,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPollable_attach.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_attach.argtypes = (
    ctypes.c_void_p,
    ctypes.c_longlong,
)

LIBNEUBOT.NeubotPollable_detach.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_fileno.restype = ctypes.c_longlong
LIBNEUBOT.NeubotPollable_fileno.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_readable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_set_readable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_unset_readable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_unset_readable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_writable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_set_writable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_unset_writable.restype = ctypes.c_int
LIBNEUBOT.NeubotPollable_unset_writable.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_set_timeout.argtypes = (
    ctypes.c_void_p,
    ctypes.c_double,
)

LIBNEUBOT.NeubotPollable_clear_timeout.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPollable_close.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPoller_construct.restype = ctypes.c_void_p
LIBNEUBOT.NeubotPoller_construct.argtypes = (
)

LIBNEUBOT.NeubotPoller_sched.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_sched.argtypes = (
    ctypes.c_void_p,
    ctypes.c_double,
    NEUBOT_HOOK_VO,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPoller_resolve.restype = ctypes.c_int
LIBNEUBOT.NeubotPoller_resolve.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int,
    ctypes.c_char_p,
    NEUBOT_HOOK_VOS,
    ctypes.py_object,
)

LIBNEUBOT.NeubotPoller_loop.argtypes = (
    ctypes.c_void_p,
)

LIBNEUBOT.NeubotPoller_break_loop.argtypes = (
    ctypes.c_void_p,
)

class EchoServer(object):

    def __init__(self, poller, use_ipv6, address, port):
        self._context = LIBNEUBOT.NeubotEchoServer_construct(poller._context,
          use_ipv6, address, port)
        if not self._context:
            raise RuntimeError('out of memory')
        LIBNEUBOT_OBJECTS.add(self)

class Pollable(object):

    def handle_read(self):
        pass

    @staticmethod
    def handle_read__(opaque):
        opaque.handle_read()

    def handle_write(self):
        pass

    @staticmethod
    def handle_write__(opaque):
        opaque.handle_write()

    def handle_close(self):
        pass

    @staticmethod
    def handle_close__(opaque):
        opaque.handle_close()

    def __init__(self, poller):
        self._c_self = ctypes.py_object(self)
        self._c_handle_read = NEUBOT_SLOT_VO(self.handle_read__)
        self._c_handle_write = NEUBOT_SLOT_VO(self.handle_write__)
        self._c_handle_close = NEUBOT_SLOT_VO(self.handle_close__)
        self._context = LIBNEUBOT.NeubotPollable_construct(poller._context,
          self._c_handle_read, self._c_handle_write, self._c_handle_close,
          self._c_self)
        if not self._context:
            raise RuntimeError('out of memory')
        LIBNEUBOT_OBJECTS.add(self)

    def attach(self, filenum):
        retval = LIBNEUBOT.NeubotPollable_attach(self._context, filenum)
        if retval != 0:
            raise RuntimeError('attach failed')
        return retval

    def detach(self):
        LIBNEUBOT.NeubotPollable_detach(self._context)

    def fileno(self):
        retval = LIBNEUBOT.NeubotPollable_fileno(self._context)
        return retval

    def set_readable(self):
        retval = LIBNEUBOT.NeubotPollable_set_readable(self._context)
        if retval != 0:
            raise RuntimeError('set_readable failed')
        return retval

    def unset_readable(self):
        retval = LIBNEUBOT.NeubotPollable_unset_readable(self._context)
        if retval != 0:
            raise RuntimeError('unset_readable failed')
        return retval

    def set_writable(self):
        retval = LIBNEUBOT.NeubotPollable_set_writable(self._context)
        if retval != 0:
            raise RuntimeError('set_writable failed')
        return retval

    def unset_writable(self):
        retval = LIBNEUBOT.NeubotPollable_unset_writable(self._context)
        if retval != 0:
            raise RuntimeError('unset_writable failed')
        return retval

    def set_timeout(self, delta):
        LIBNEUBOT.NeubotPollable_set_timeout(self._context, delta)

    def clear_timeout(self):
        LIBNEUBOT.NeubotPollable_clear_timeout(self._context)

    def close(self):
        LIBNEUBOT.NeubotPollable_close(self._context)
        LIBNEUBOT_OBJECTS.remove(self)

class Poller(object):

    def __init__(self):
        self._context = LIBNEUBOT.NeubotPoller_construct()
        if not self._context:
            raise RuntimeError('out of memory')
        LIBNEUBOT_OBJECTS.add(self)

    def sched(self, delta, callback, opaque):
        context = NeubotHookVoContext(callback, opaque,
          self.sched_callback__)
        LIBNEUBOT_OBJECTS.add(context)
        retval = LIBNEUBOT.NeubotPoller_sched(self._context, delta,
          context.cfunc, context)
        if retval != 0:
            raise RuntimeError('sched failed')
        return retval

    @staticmethod
    def sched_callback__(context):
        LIBNEUBOT_OBJECTS.remove(context)
        context.callback(context.opaque)

    def resolve(self, use_ipv6, name, callback, opaque):
        retval = LIBNEUBOT.NeubotPoller_resolve(self._context, use_ipv6, name,
          callback, opaque)
        if retval != 0:
            raise RuntimeError('resolve failed')
        return retval

    def loop(self):
        LIBNEUBOT.NeubotPoller_loop(self._context)

    def break_loop(self):
        LIBNEUBOT.NeubotPoller_break_loop(self._context)

