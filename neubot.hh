//
// LibNeubot interface - Public domain.
// WARNING: Autogenerated file - do not edit!
//

#include <stdlib.h>
#include <new>

namespace Neubot {

#include <neubot.h>

    class EchoServer;
    class HttpClient;
    class Pollable;
    class Poller;

    class EchoServer {
        struct NeubotEchoServer *_context;

      public:

// Swig doesn't understand the cast operator
#ifndef SWIG
        operator struct NeubotEchoServer *(void) {
            return (this->_context);
        }
#endif

        EchoServer(Poller *poller, int use_ipv6, const char *address,
          const char *port) {
            this->_context = NeubotEchoServer_construct(
              (struct NeubotPoller *) poller, use_ipv6, address, port);
            if (this->_context == NULL)
                throw new std::bad_alloc();
        };

    };

    class HttpClient {
        struct NeubotHttpClient *_context;

        static void handle_begin__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_begin();
        };

        static void handle_body__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_body();
        };

        static void handle_close__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_close();
        };

        static void handle_connect__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_connect();
        };

        static void handle_end__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_end();
        };

        static void handle_flush__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_flush();
        };

        static void handle_headers__(void *opaque) {
            HttpClient *self = (HttpClient *) opaque;
            self->handle_headers();
        };

      public:

// Swig doesn't understand the cast operator
#ifndef SWIG
        operator struct NeubotHttpClient *(void) {
            return (this->_context);
        }
#endif

        virtual void handle_begin(void) = 0;

        virtual void handle_body(void) = 0;

        virtual void handle_close(void) = 0;

        virtual void handle_connect(void) = 0;

        virtual void handle_end(void) = 0;

        virtual void handle_flush(void) = 0;

        virtual void handle_headers(void) = 0;

        HttpClient(Poller *poller) {
            this->_context = NeubotHttpClient_construct(
              (struct NeubotPoller *) poller, this->handle_begin__,
              this->handle_body__, this->handle_close__,
              this->handle_connect__, this->handle_end__, this->handle_flush__,
              this->handle_headers__, this);
            if (this->_context == NULL)
                throw new std::bad_alloc();
        };

        int connect(const char *family, const char *address,
          const char *port) {
            return (NeubotHttpClient_connect(this->_context, family, address,
              port));
        };

        int write(const char *data, size_t count) {
            return (NeubotHttpClient_write(this->_context, data, count));
        };

        int writes(const char *str) {
            return (NeubotHttpClient_writes(this->_context, str));
        };

        int flush(void) {
            return (NeubotHttpClient_flush(this->_context));
        };

        int code(void) {
            return (NeubotHttpClient_code(this->_context));
        };

        const char *reason(void) {
            return (NeubotHttpClient_reason(this->_context));
        };

        const char *header(const char *key) {
            return (NeubotHttpClient_header(this->_context, key));
        };

        size_t body_length(void) {
            return (NeubotHttpClient_body_length(this->_context));
        };

        const char *body_string(void) {
            return (NeubotHttpClient_body_string(this->_context));
        };

        virtual ~HttpClient(void) {
            NeubotHttpClient_close(this->_context);
        };

    };

    class Pollable {
        struct NeubotPollable *_context;

        static void handle_read__(void *opaque) {
            Pollable *self = (Pollable *) opaque;
            self->handle_read();
        };

        static void handle_write__(void *opaque) {
            Pollable *self = (Pollable *) opaque;
            self->handle_write();
        };

        static void handle_close__(void *opaque) {
            Pollable *self = (Pollable *) opaque;
            self->handle_close();
        };

      public:

// Swig doesn't understand the cast operator
#ifndef SWIG
        operator struct NeubotPollable *(void) {
            return (this->_context);
        }
#endif

        virtual void handle_read(void) = 0;

        virtual void handle_write(void) = 0;

        virtual void handle_close(void) = 0;

        Pollable(Poller *poller) {
            this->_context = NeubotPollable_construct(
              (struct NeubotPoller *) poller, this->handle_read__,
              this->handle_write__, this->handle_close__, this);
            if (this->_context == NULL)
                throw new std::bad_alloc();
        };

        int attach(long long filenum) {
            return (NeubotPollable_attach(this->_context, filenum));
        };

        void detach(void) {
            NeubotPollable_detach(this->_context);
        };

        long long fileno(void) {
            return (NeubotPollable_fileno(this->_context));
        };

        int set_readable(void) {
            return (NeubotPollable_set_readable(this->_context));
        };

        int unset_readable(void) {
            return (NeubotPollable_unset_readable(this->_context));
        };

        int set_writable(void) {
            return (NeubotPollable_set_writable(this->_context));
        };

        int unset_writable(void) {
            return (NeubotPollable_unset_writable(this->_context));
        };

        void set_timeout(double delta) {
            NeubotPollable_set_timeout(this->_context, delta);
        };

        void clear_timeout(void) {
            NeubotPollable_clear_timeout(this->_context);
        };

        virtual ~Pollable(void) {
            NeubotPollable_close(this->_context);
        };

    };

    class Poller {
        struct NeubotPoller *_context;

      public:

// Swig doesn't understand the cast operator
#ifndef SWIG
        operator struct NeubotPoller *(void) {
            return (this->_context);
        }
#endif

        Poller(void) {
            this->_context = NeubotPoller_construct();
            if (this->_context == NULL)
                throw new std::bad_alloc();
        };


// We use another strategy to generate closure code
#ifndef SWIG
        int sched(double delta, neubot_hook_vo callback, void *opaque) {
            return (NeubotPoller_sched(this->_context, delta, callback, opaque));
        };
#endif


// We use another strategy to generate closure code
#ifndef SWIG
        int defer_read(long long fileno, neubot_hook_vo handle_ok,
          neubot_hook_vo handle_timeout, void *opaque, double timeout) {
            return (NeubotPoller_defer_read(this->_context, fileno, handle_ok,
              handle_timeout, opaque, timeout));
        };
#endif


// We use another strategy to generate closure code
#ifndef SWIG
        int defer_write(long long fileno, neubot_hook_vo handle_ok,
          neubot_hook_vo handle_timeout, void *opaque, double timeout) {
            return (NeubotPoller_defer_write(this->_context, fileno, handle_ok,
              handle_timeout, opaque, timeout));
        };
#endif


// We use another strategy to generate closure code
#ifndef SWIG
        int resolve(int use_ipv6, const char *name,
          neubot_hook_vos callback, void *opaque) {
            return (NeubotPoller_resolve(this->_context, use_ipv6, name,
              callback, opaque));
        };
#endif

        void loop(void) {
            NeubotPoller_loop(this->_context);
        };

        void break_loop(void) {
            NeubotPoller_break_loop(this->_context);
        };

    };

};
