#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

def python_type(types, name):
    return types.get(name, name)

def gen_python_imports(stream):
    stream.write("import ctypes\n")
    stream.write("import sys\n")
    stream.write("\n")
    stream.write('if sys.platform == "darwin":\n')
    stream.write('    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.dylib.1"\n')
    stream.write("else:\n")
    stream.write('    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.so.1"\n')
    stream.write("\n")
    stream.write("LIBNEUBOT = ctypes.CDLL(LIBNEUBOT_NAME)\n")

def gen_python_prototype(stream, types, class_name, method_info):
    if method_info[0] == "__construct__":
        retval = class_name + "_p"
        funcname = class_name + "_construct"
        args = method_info[1:]
    elif method_info[0] == "__destruct__":
        retval = "void"
        funcname = class_name + "_" + method_info[1]
        args = [(class_name + "_p", "self")]
    else:
        retval = method_info[0]
        funcname = class_name + "_" + method_info[1]
        args = method_info[2:]
        args.insert(0, (class_name + "_p", "self"))
    if retval != "void":
        stream.write("LIBNEUBOT.%s.restype = %s\n" % (funcname,
          python_type(types, retval)))
    stream.write("LIBNEUBOT.%s.argtypes = (\n" % funcname)
    for argtype, _ in args:
        argtype = python_type(types, argtype)
        stream.write("    %s,\n" % argtype)
    stream.write(")\n")

def gen_python_func_top(stream, types, retval_type, func_name, arguments):
    stream.write("    ")
    nwritten = 4
    stream.write("def ")
    nwritten += 4
    stream.write(func_name)
    nwritten += len(func_name)
    stream.write("(")
    nwritten += 1
    if arguments:
        for index, arg in enumerate(arguments):
            if index > 0:
                stream.write(",")
                nwritten += 1
            _, argname = arg
            if nwritten + len(argname) >= 75:
                stream.write("\n")
                stream.write("          ")
                nwritten = 10
            elif index > 0:
                stream.write(" ")
                nwritten += 1
            stream.write(argname)
            nwritten += len(argname)
    else:
        stream.write("")
    stream.write("):\n")

def gen_python_func_bottom(stream):
    stream.write("\n")

def gen_python_slot_vo(stream, class_name, slot_name):
    stream.write("    ")
    stream.write("def %s(self):\n" % slot_name)
    stream.write("        pass\n")
    stream.write("\n")
    stream.write("    ")
    stream.write("@staticmethod\n")
    stream.write("    ")
    stream.write("def %s__(opaque):\n" % slot_name)
    stream.write("        opaque.%s()\n" % slot_name)
    stream.write("\n")

def gen_python_callfunc(stream, nwritten, func_name, args):
    stream.write(func_name)
    nwritten += len(func_name)
    stream.write("(")
    nwritten += 1
    for index, arg in enumerate(args):
        if index > 0:
            stream.write(",")
            nwritten += 1
        if arg[0] and arg[0].endswith("_p"):
            arg[1] = arg[1] + "._context"
        if nwritten + len(arg[1]) >= 78:
            stream.write("\n")
            stream.write("          ")
            nwritten = 10
        elif index > 0:
            stream.write(" ")
            nwritten += 1
        stream.write(arg[1])
        nwritten += len(arg[1])
    stream.write(")")

def gen_python_init(stream, types, class_name, struct_name, init_args):
    external_args = []
    nargs = []
    slots_objs = 0
    for arg in init_args:
        if arg[0] == "slot_vo":
            gen_python_slot_vo(stream, class_name, arg[1])
            nargs.append((None, "self._c_" + arg[1]))
        elif arg[0] == "Object":
            nargs.append((None, "self._c_self"))
            slots_objs += 1
        else:
            external_args.append(arg)
            nargs.append(arg)
    if slots_objs > 1:
        raise RuntimeError("There must be only one slot object")
    external_args.insert(0, (None, "self"))
    gen_python_func_top(stream, types, None, "__init__", external_args)
    if slots_objs == 1:
        stream.write("        ")
        stream.write("self._c_self = ctypes.py_object(self)\n")
        for arg in init_args:
            if arg[0] == "slot_vo":
                stream.write("        ")
                stream.write("self._c_%s = NEUBOT_SLOT_VO(self.%s__)\n" % (
                  arg[1], arg[1]))
    stream.write("        ")
    nwritten = 8
    stream.write("self._context = ")
    nwritten += 17
    gen_python_callfunc(stream, nwritten, "LIBNEUBOT.%s_construct"
      % struct_name, nargs)
    stream.write("\n")
    stream.write("        ")
    stream.write("if not self._context:\n")
    stream.write("            ")
    stream.write("raise RuntimeError('out of memory')\n")
    stream.write("        ")
    stream.write("LIBNEUBOT_OBJECTS.add(self)\n")

def gen_python_method(stream, types, struct_name, retval_type,
                   meth_name, meth_args):
    meth_args.insert(0, (None, "self"))
    gen_python_func_top(stream, types, retval_type, meth_name, meth_args)
    meth_args[0] = (None, "self._context")

    new_args = []
    hook_obj = None
    hook_vo = None
    for argtype, argname in meth_args:
        if argtype == "Object":
            if hook_obj != None:
                raise RuntimeError("More than one hook object")
            hook_obj = argname
            new_args.append((None, "context"))
        elif argtype == "hook_vo":
            if hook_vo != None:
                raise RuntimeError("More than one hook_vo")
            hook_vo = argname
            new_args.append((None, "context.cfunc"))
        else:
            new_args.append((argtype, argname))
    if hook_obj and hook_vo:
        stream.write("        ")
        stream.write("context = NeubotHookVoContext(%s, %s,\n" % (hook_vo,
          hook_obj))
        stream.write("          ")
        stream.write("self.%s_callback__)\n" % meth_name)
        stream.write("        ")
        stream.write("LIBNEUBOT_OBJECTS.add(context)\n")
        meth_args = new_args

    stream.write("        ")
    nwritten = 8
    if retval_type != "void":
        stream.write("retval = ")
        nwritten += 9
    gen_python_callfunc(stream, nwritten, "LIBNEUBOT.%s_%s" %
      (struct_name, meth_name), meth_args)
    stream.write("\n")
    if retval_type == "status_t":
        stream.write("        ")
        stream.write("if retval != 0:\n")
        stream.write("            ")
        stream.write("raise RuntimeError('%s failed')\n" % meth_name)
    if retval_type != "void":
        stream.write("        ")
        stream.write("return retval\n")

    if hook_obj and hook_vo:
        stream.write("\n")
        stream.write("    ")
        stream.write("@staticmethod\n")
        stream.write("    ")
        stream.write("def %s_callback__(context):\n" % meth_name)
        stream.write("        ")
        stream.write("LIBNEUBOT_OBJECTS.remove(context)\n")
        stream.write("        ")
        stream.write("context.callback(context.opaque)\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)
    stream = sys.stdout

    stream.write("#\n")
    stream.write("# LibNeubot interface - Public domain.\n")
    stream.write("# WARNING: Autogenerated file - do not edit!\n")
    stream.write("#\n")
    stream.write("\n")

    stream.write("# pylint: disable = C0111\n")
    stream.write("\n")

    gen_python_imports(stream)

    stream.write("LIBNEUBOT_OBJECTS = set()\n")
    stream.write("\n")

    stream.write("NEUBOT_SLOT_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)\n")
    stream.write("NEUBOT_SLOT_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,\n")
    stream.write("  ctypes.c_char_p)\n")
    stream.write("\n")
    stream.write("NEUBOT_HOOK_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)\n")
    stream.write("NEUBOT_HOOK_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,\n")
    stream.write("  ctypes.c_char_p)\n")
    stream.write("\n")

    stream.write("class NeubotHookVoContext(object):\n")
    stream.write("    def __init__(self, callback, opaque, cfunc):\n")
    stream.write("        self.callback = callback\n")
    stream.write("        self.opaque = opaque\n")
    stream.write("        self.cfunc = NEUBOT_HOOK_VO(cfunc)\n")
    stream.write("\n")

    types = {
        "Object": "ctypes.py_object",
        "cstring": "ctypes.c_char_p",
        "double": "ctypes.c_double",
        "hook_vo": "NEUBOT_HOOK_VO",
        "hook_vos": "NEUBOT_HOOK_VOS",
        "int": "ctypes.c_int",
        "long long": "ctypes.c_longlong",
        "slot_vo": "NEUBOT_SLOT_VO",
        "slot_vos": "NEUBOT_SLOT_VOS",
        "status_t": "ctypes.c_int",
        "void_p": "ctypes.c_void_p",
    }

    # Process all class names once, to register all the types
    for struct_name in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        types[struct_name + "_p"] = "ctypes.c_void_p"

    # Process once more, to generate all the prototypes
    for struct_name in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        for method_info in interface["classes"][struct_name]:
            gen_python_prototype(stream, types, struct_name, method_info)
            stream.write("\n")

    # Finally, generate the wrapper classes
    for struct_name in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        stream.write("class %s(object):\n" % class_name)
        stream.write("\n")

        for method_info in interface["classes"][struct_name]:
            if method_info[0] == "__construct__":
                gen_python_init(stream, types, class_name, struct_name,
                  method_info[1:])
            elif method_info[0] == "__destruct__":
                gen_python_method(stream, types, struct_name, "void",
                  method_info[1], method_info[2:])
                stream.write("        ")
                stream.write("LIBNEUBOT_OBJECTS.remove(self)\n")
            else:
                gen_python_method(stream, types, struct_name, method_info[0],
                  method_info[1], method_info[2:])
            gen_python_func_bottom(stream);

if __name__ == "__main__":
    main()
