#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

def cxx_type(types, name):
    return types.get(name, name)

def gen_cxx_init(stream, types, class_name, struct_name, init_args, slots):
    stream.write("      ")
    stream.write("%s(" % class_name)
    for index, arg in enumerate(init_args):
        argtype, argname = arg
        argtype = cxx_type(types, argtype)
        stream.write("%s %s" % (argtype, argname))
        if index < len(init_args) - 1:
            stream.write(", ")
    stream.write(") {\n")
    stream.write("        ")
    stream.write("this->_context = ")
    stream.write("%s_construct(" % struct_name)
    for index, arg in enumerate(init_args):
        stream.write("%s" % arg[1])
        if index < len(init_args) - 1:
            stream.write(", ")
    stream.write(");\n")
    stream.write("        ")
    stream.write("if (this->_context == NULL)\n")
    stream.write("          ")
    stream.write("throw new std::bad_alloc();\n")
    for slot in slots:
        stream.write("        ")
        stream.write("%s_set_%s_slot(this->_context, " % (struct_name, slot))
        stream.write("this->%s_callback, this);\n" % slot)
    stream.write("      };\n")
    stream.write("\n")

def gen_cxx_slot(stream, class_name, slot_name):
    stream.write("      ")
    stream.write("virtual void %s(void) {\n" % slot_name)
    stream.write("      };\n")
    stream.write("\n")
    stream.write("      ")
    stream.write("static void %s_callback(void *opaque) {\n" % slot_name)
    stream.write("        ")
    stream.write("%s *self;\n" % class_name)
    stream.write("        ")
    stream.write("self = (%s *) opaque;\n" % class_name)
    stream.write("        ")
    stream.write("self->%s();\n" % slot_name)
    stream.write("      };\n")
    stream.write("\n")

def gen_cxx_del(stream, class_name, struct_name):
    stream.write("      ")
    stream.write("~%s(void) {\n" % class_name)
    stream.write("        ")
    stream.write("%s_free(this->_context);\n" % struct_name)
    stream.write("      };\n")
    stream.write("\n")

def gen_cxx_method(stream, types, struct_name, retval_type,
                      meth_name, meth_args):
    stream.write("      ")
    stream.write("%s " % cxx_type(types, retval_type))
    stream.write("%s(" % meth_name)
    if meth_args:
        for index, meth_arg in enumerate(meth_args):
            stream.write("%s %s" % (cxx_type(types, meth_arg[0]), meth_arg[1]))
            if index < len(meth_args) -1:
                stream.write(", ")
    else:
        stream.write("void")
    stream.write(") {\n")
    stream.write("        ")
    if retval_type != "void":
        stream.write("return (")
    stream.write("%s_%s(this->_context" % (struct_name, meth_name))
    if meth_args:
        for meth_arg in meth_args:
            stream.write(", %s" % meth_arg[1])
    stream.write(")")
    if retval_type != "void":
        stream.write(")")
    stream.write(";\n")
    stream.write("      };\n")
    stream.write("\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)
    stream = sys.stdout

    stream.write("//\n")
    stream.write("// LibNeubot interface - Public domain.\n")
    stream.write("// WARNING: Autogenerated file - do not edit!\n")
    stream.write("//\n")
    stream.write("\n")

    stream.write("namespace Neubot {\n")
    stream.write("\n")

    types = {
        "Object": "void *",
        "cstring": "const char *",
        "status_t": "int",
        "void_p": "void *",
    }

    # Process all class names once, to register all the types
    for struct_name in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        types[struct_name + "_p"] = "struct ::" + struct_name + " *"
        types[struct_name] = "struct ::" + struct_name
        types[class_name + "_p"] = class_name + " *"
        types[class_name] = class_name

    for struct_name in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        struct_name = "::" + struct_name
        stream.write("  class %s {\n" % class_name)
        stream.write("      struct %s *_context;\n" % struct_name);
        stream.write("\n")

        stream.write("    public:\n")

        stream.write("      operator struct %s *() {\n" % struct_name)
        stream.write("        return (this->_context);\n")
        stream.write("      }\n")
        stream.write("\n")

        ctor = None
        slots = []

        for method_info in interface["classes"][struct_name[2:]]:
            if method_info[0] == "__construct__":
                ctor = method_info[1:]
            elif method_info[0] == "__slot__":
                gen_cxx_slot(stream, class_name, method_info[1])
                slots.append(method_info[1])
            elif method_info[0] == "__destroy__":
                gen_cxx_del(stream, class_name, struct_name)
            else:
                gen_cxx_method(stream, types, struct_name, method_info[0],
                  method_info[1], method_info[2:])

        if ctor != None:
            gen_cxx_init(stream, types, class_name, struct_name, ctor, slots)

        stream.write("  };\n")
        stream.write("\n")

    stream.write("};\n")

if __name__ == "__main__":
    main()
